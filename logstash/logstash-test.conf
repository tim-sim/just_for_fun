input { 
  file { 
    path => "D:/logstash/*.log"
	start_position => "beginning"
	close_older => 1
    codec => multiline {
      pattern => "^%{TIMESTAMP_ISO8601} "
      negate => true
      what => previous
    }
  }
} 

filter {
  dissect {
    mapping => {
	  "message" => "%{timestamp} %{+timestamp} %{debug_level} [%{threads}] %{source} - [%{?ip}:%{port}] %{content}"
	}
  }

  if [source] != "HttpInterface" {
    drop {}
  }

  date {
    match => [ "timestamp", "yyyy-MM-dd HH:mm:ss,SSS" ]
  }

  kv {
    source => "content"
	include_keys => [ "RequestId", "Method", "Uri" ]
	field_split => " \[\]\r\n"
  }

  if [RequestId] {
    mutate {
	  add_tag => [ "request" ]
    }
  }

  if [Uri] {
    grok {
      match => {
        "Uri" => "%{URIPROTO}://%{URIHOST:servername}/%{WORD:type}/web(/%{WORD:api}%{URIPATHPARAM})?"
      }
      add_tag => [ "URI_parsed" ]
    }

	if [api] {
      mutate {
        add_tag => [ "got_api" ]
      }
    }
  }

  kv {
    source => "content"
	include_keys => [ "X-Forwarded-For", "X-dev", "Content-Length", "Content-Type", "Accept", "Host", "Accept-Encoding", "User-Agent" ]
	field_split => " \n"
	value_split => ":"
	trim => "\r\n,;"
    add_tag => [ "got_headers" ]
  }

  grok {
    match => ["path","%{GREEDYDATA}/%{GREEDYDATA:[@metadata][filename]}\.log"]
  }

  mutate {
	remove_field => [ "message", "content", "source", "timestamp", "filename" ]
  }
}

output {
  stdout { codec => rubydebug }
  elasticsearch {
    codec => json
  }
#  file { 
#    path => "D:/logstash/%{[@metadata][filename]}.json"
#    codec => json
#  }
}
